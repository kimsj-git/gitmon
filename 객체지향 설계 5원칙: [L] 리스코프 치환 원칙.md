## SO[L]ID: 리스코프 치환 원칙

> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서, 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

예시를 들어 설명해보면, increase(), decrease() 메서드를 정의한 인터페이스가 있다고 가정하자.

해당 인터페이스를 호출하는 클라이언트는 increase() 를 호출하면 값이 증가하고, decrease()를 호출하면 값이 감소할 것이라고 기대(계약)한다.

그런데 구현체에서 반대로 구현해놓거나, 전혀 다른 의미로 동작하게 만든다면 클라이언트는 더이상 인터페이스를 **신뢰할 수 없게 되며**, 이는 리스코프 치환 원칙을 위반한 것이다.

즉, **리스코프 치환 원칙은 다형성을 안전하게 사용하기 위해, 하위 타입이 상위 타입의 의미적 계약을 반드시 지켜야 한다는 원칙**이다.

(인터페이스-구현체 관계로 설명했지만, 부모 클래스-자식 클래스 간에도 동일하게 적용된다.)

```kotlin
// 🤝 인터페이스 - 값을 증가 또는 감소시키는 의미로 설계됨
interface Calculator {
    fun increase(x: Int): Int
    fun decrease(x: Int): Int
}

// 👍 리스코프 치환 원칙 성립 - 계약을 지킨 구현체
class GoodCalculator : Calculator {
    override fun increase(x: Int): Int {
        return x + 1
    }
    override fun decrease(x: Int): Int {
        return x - 1
    }
}

// 👎 리스코프 치환 원칙 위반 : 컴파일은 되지만 인터페이스의 의미적 계약을 위반한 구현체
class BadCalculator : Calculator {
    override fun increase(x: Int): Int {
        return x - 1 // 감소시킴 → 계약 위반
    }
    override fun decrease(x: Int): Int {
        return x + 1 // 증가시킴 → 계약 위반
    }
}
```